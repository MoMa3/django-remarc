# Generated by Django 4.2.x
from decimal import Decimal
from django.db import migrations


CATEGORY_NAMES = [
    "Clothing",
    "Footwear",
    "Accessories",
    "Outdoor",
    "Electronics",
]

TAG_NAMES = [
    "waterproof",
    "cotton",
    "leather",
    "winter",
    "summer",
    "lightweight",
    "eco",
    "premium",
    "budget",
    "durable",
]


def seed_forward(apps, schema_editor):
    Category = apps.get_model("shop", "Category")
    Tag = apps.get_model("shop", "Tag")
    Product = apps.get_model("shop", "Product")

    # --- Create categories (idempotent) ---
    Category.objects.bulk_create(
        [Category(name=n) for n in CATEGORY_NAMES],
        ignore_conflicts=True,
    )
    categories = list(Category.objects.filter(name__in=CATEGORY_NAMES).order_by("id"))

    # --- Create tags (idempotent) ---
    Tag.objects.bulk_create(
        [Tag(name=n) for n in TAG_NAMES],
        ignore_conflicts=True,
    )
    tags = list(Tag.objects.filter(name__in=TAG_NAMES).order_by("id"))

    if not categories or not tags:
        # Safety guard if something odd happened
        return

    # --- Create products (20+) ---
    # Round-robin categories; simple, realistic pricing and descriptions.
    products_to_create = []
    for i in range(1, 21):
        cat = categories[(i - 1) % len(categories)]
        products_to_create.append(
            Product(
                name=f"Sample Product {i}",
                description=(
                    f"A solid option for daily use. Variant #{i}. "
                    f"Features may include {TAG_NAMES[(i-1) % len(TAG_NAMES)]}."
                ),
                price=Decimal(f"{20 + i}"),
                category=cat,
            )
        )

    Product.objects.bulk_create(products_to_create, ignore_conflicts=True)

    # Refetch the created products (by our naming convention) to ensure we have PKs
    created_products = list(
        Product.objects.filter(name__startswith="Sample Product ").order_by("id")
    )

    # --- Attach tags ---
    # For variety: each product gets 2â€“4 tags by round-robin.
    tlen = len(tags)
    for idx, p in enumerate(created_products):
        # choose tags in a sliding window
        start = idx % tlen
        chosen = {
            tags[start % tlen].id,
            tags[(start + 1) % tlen].id,
            tags[(start + 2) % tlen].id if (idx % 3) else tags[(start + 3) % tlen].id,
        }
        p.tags.add(*chosen)


def seed_reverse(apps, schema_editor):
    Category = apps.get_model("shop", "Category")
    Tag = apps.get_model("shop", "Tag")
    Product = apps.get_model("shop", "Product")

    # Delete products we created first (FK PROTECT on category)
    Product.objects.filter(name__startswith="Sample Product ").delete()

    # Then remove our specific tags/categories (safe if unused elsewhere)
    Tag.objects.filter(name__in=TAG_NAMES).delete()
    Category.objects.filter(name__in=CATEGORY_NAMES).delete()


class Migration(migrations.Migration):

    dependencies = [
        ("shop", "0001_initial"),  # adjust if your initial migration has a different name
    ]

    operations = [
        migrations.RunPython(seed_forward, seed_reverse),
    ]
